{{- if .Values.db.migration.enabled -}}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "supabase.fullname" . }}-db-migrations
  labels:
    {{- include "supabase.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-10"
data:
  00-alter-supabase_admin.sql: |
    -- These are required so that the users receive grants whenever "supabase_admin" creates tables/function
    alter default privileges for user supabase_admin in schema public grant all
        on sequences to postgres, anon, authenticated, service_role;
    alter default privileges for user supabase_admin in schema public grant all
        on tables to postgres, anon, authenticated, service_role;
    alter default privileges for user supabase_admin in schema public grant all
        on functions to postgres, anon, authenticated, service_role;

  00-extension.sql: |
    CREATE SCHEMA IF NOT exists extensions;
    CREATE EXTENSION IF NOT EXISTS pg_stat_statements with schema extensions;

  10000000000000_demote-postgres.sql: |
    -- migrate:up

    -- demote postgres user
    ALTER ROLE postgres CREATEDB CREATEROLE LOGIN BYPASSRLS;
    GRANT rds_replication TO postgres;
    GRANT ALL ON DATABASE postgres TO postgres;
    GRANT ALL ON SCHEMA auth TO postgres;
    GRANT ALL ON SCHEMA extensions TO postgres;
    GRANT ALL ON SCHEMA storage TO postgres;
    GRANT ALL ON ALL TABLES IN SCHEMA auth TO postgres;
    GRANT ALL ON ALL TABLES IN SCHEMA storage TO postgres;
    GRANT ALL ON ALL TABLES IN SCHEMA extensions TO postgres;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO postgres;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA storage TO postgres;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA extensions TO postgres;
    GRANT ALL ON ALL ROUTINES IN SCHEMA auth TO postgres;
    GRANT ALL ON ALL ROUTINES IN SCHEMA storage TO postgres;
    GRANT ALL ON ALL ROUTINES IN SCHEMA extensions TO postgres;
    -- ALTER ROLE postgres NOSUPERUSER CREATEDB CREATEROLE LOGIN REPLICATION BYPASSRLS;

    -- migrate:down

  20211115181400_update-auth-permissions.sql: |
    -- migrate:up

    -- update auth schema permissions
    GRANT ALL PRIVILEGES ON SCHEMA auth TO supabase_auth_admin;
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA auth TO supabase_auth_admin;
    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA auth TO supabase_auth_admin;

    ALTER table IF EXISTS "auth".users OWNER TO supabase_auth_admin;
    ALTER table IF EXISTS "auth".refresh_tokens OWNER TO supabase_auth_admin;
    ALTER table IF EXISTS "auth".audit_log_entries OWNER TO supabase_auth_admin;
    ALTER table IF EXISTS "auth".instances OWNER TO supabase_auth_admin;
    ALTER table IF EXISTS "auth".schema_migrations OWNER TO supabase_auth_admin;

    GRANT USAGE ON SCHEMA auth TO postgres;
    GRANT ALL ON ALL TABLES IN SCHEMA auth TO postgres, dashboard_user;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO postgres, dashboard_user;
    GRANT ALL ON ALL ROUTINES IN SCHEMA auth TO postgres, dashboard_user;
    -- ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON TABLES TO postgres, dashboard_user;
    -- ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON SEQUENCES TO postgres, dashboard_user;
    -- ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON ROUTINES TO postgres, dashboard_user;

    -- migrate:down

  20211115999999_update-auth-permissions_aurora.sql: |
    ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON TABLES TO postgres, dashboard_user;
    ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON SEQUENCES TO postgres, dashboard_user;
    ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON ROUTINES TO postgres, dashboard_user;

  20211118015519_create-realtime-schema.sql: |
    -- migrate:up

    -- create realtime schema for Realtime RLS (WALRUS)
    CREATE SCHEMA IF NOT EXISTS realtime;

    -- migrate:down

  20211122051245_update-realtime-permissions.sql: |
    -- migrate:up

    -- update realtime schema permissions
    GRANT USAGE ON SCHEMA realtime TO postgres;
    GRANT ALL ON ALL TABLES IN SCHEMA realtime TO postgres, dashboard_user;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA realtime TO postgres, dashboard_user;
    GRANT ALL ON ALL ROUTINES IN SCHEMA realtime TO postgres, dashboard_user;

    -- migrate:down

  20211124212715_update-auth-owner.sql: |
    -- migrate:up

    -- update owner for auth.uid, auth.role and auth.email functions
    DO $$
    BEGIN
        ALTER FUNCTION auth.uid owner to supabase_auth_admin;
    EXCEPTION WHEN OTHERS THEN
        RAISE WARNING 'Error encountered when changing owner of auth.uid to supabase_auth_admin';
    END $$;

    DO $$
    BEGIN
        ALTER FUNCTION auth.role owner to supabase_auth_admin;
    EXCEPTION WHEN OTHERS THEN
        RAISE WARNING 'Error encountered when changing owner of auth.role to supabase_auth_admin';
    END $$;

    DO $$
    BEGIN
        ALTER FUNCTION auth.email owner to supabase_auth_admin;
    EXCEPTION WHEN OTHERS THEN
        RAISE WARNING 'Error encountered when changing owner of auth.email to supabase_auth_admin';
    END $$;
    -- migrate:down

  20211130151719_update-realtime-permissions.sql: |
    -- migrate:up

    -- Update future objects' permissions
    ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON TABLES TO postgres, dashboard_user;
    ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON SEQUENCES TO postgres, dashboard_user;
    ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON ROUTINES TO postgres, dashboard_user;

    -- migrate:down

  20220118070449_enable-safeupdate-postgrest.sql: |
    -- migrate:up
    -- ALTER ROLE authenticator SET session_preload_libraries = 'safeupdate';

    -- migrate:down

  20220126121436_finer-postgrest-triggers.sql: |
    -- migrate:up

    drop event trigger if exists api_restart;
    drop function if exists extensions.notify_api_restart();

    -- https://postgrest.org/en/latest/schema_cache.html#finer-grained-event-trigger
    -- watch create and alter
    CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch() RETURNS event_trigger AS $$
    DECLARE
      cmd record;
    BEGIN
      FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
      LOOP
        IF cmd.command_tag IN (
          'CREATE SCHEMA', 'ALTER SCHEMA'
        , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'
        , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'
        , 'CREATE VIEW', 'ALTER VIEW'
        , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'
        , 'CREATE FUNCTION', 'ALTER FUNCTION'
        , 'CREATE TRIGGER'
        , 'CREATE TYPE'
        , 'CREATE RULE'
        , 'COMMENT'
        )
        -- don't notify in case of CREATE TEMP table or other objects created on pg_temp
        AND cmd.schema_name is distinct from 'pg_temp'
        THEN
          NOTIFY pgrst, 'reload schema';
        END IF;
      END LOOP;
    END; $$ LANGUAGE plpgsql;

    -- watch drop
    CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch() RETURNS event_trigger AS $$
    DECLARE
      obj record;
    BEGIN
      FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
      LOOP
        IF obj.object_type IN (
          'schema'
        , 'table'
        , 'foreign table'
        , 'view'
        , 'materialized view'
        , 'function'
        , 'trigger'
        , 'type'
        , 'rule'
        )
        AND obj.is_temporary IS false -- no pg_temp objects
        THEN
          NOTIFY pgrst, 'reload schema';
        END IF;
      END LOOP;
    END; $$ LANGUAGE plpgsql;

    DROP EVENT TRIGGER IF EXISTS pgrst_ddl_watch;
    CREATE EVENT TRIGGER pgrst_ddl_watch
      ON ddl_command_end
      EXECUTE PROCEDURE extensions.pgrst_ddl_watch();

    DROP EVENT TRIGGER IF EXISTS pgrst_drop_watch;
    CREATE EVENT TRIGGER pgrst_drop_watch
      ON sql_drop
      EXECUTE PROCEDURE extensions.pgrst_drop_watch();


    -- migrate:down

  20220224211803_fix-postgrest-supautils.sql: |
    -- migrate:up

    -- Note: supatils extension is not installed in docker image.

    DO $$
    DECLARE
      supautils_exists boolean;
    BEGIN
      supautils_exists = (
          select count(*) = 1
          from pg_available_extensions
          where name = 'supautils'
      );

      IF supautils_exists
      THEN
      ALTER ROLE authenticator SET session_preload_libraries = supautils, safeupdate;
      END IF;
    END $$;

    -- migrate:down

  20220317095840_pg_graphql.sql: |
    -- migrate:up
    create schema if not exists graphql_public;

    -- obsolete signature: https://github.com/supabase/infrastructure/pull/5524/files
    drop function if exists graphql_public.graphql(text, text, jsonb);
    -- GraphQL Placeholder Entrypoint
    create or replace function graphql_public.graphql(
        "operationName" text default null,
        query text default null,
        variables jsonb default null,
        extensions jsonb default null
    )
        returns jsonb
        language plpgsql
    as $$
        DECLARE
            server_version float;
        BEGIN
            server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);

            IF server_version >= 14 THEN
                RETURN jsonb_build_object(
                    'data', null::jsonb,
                    'errors', array['pg_graphql extension is not enabled.']
                );
            ELSE
                RETURN jsonb_build_object(
                    'data', null::jsonb,
                    'errors', array['pg_graphql is only available on projects running Postgres 14 onwards.']
                );
            END IF;
        END;
    $$;

    grant usage on schema graphql_public to postgres, anon, authenticated, service_role;
    alter default privileges in schema graphql_public grant all on tables to postgres, anon, authenticated, service_role;
    alter default privileges in schema graphql_public grant all on functions to postgres, anon, authenticated, service_role;
    alter default privileges in schema graphql_public grant all on sequences to postgres, anon, authenticated, service_role;

    alter default privileges for user supabase_admin in schema graphql_public grant all
        on sequences to postgres, anon, authenticated, service_role;
    alter default privileges for user supabase_admin in schema graphql_public grant all
        on tables to postgres, anon, authenticated, service_role;
    alter default privileges for user supabase_admin in schema graphql_public grant all
        on functions to postgres, anon, authenticated, service_role;

    -- Trigger upon enabling pg_graphql
    CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()
    RETURNS event_trigger
    LANGUAGE plpgsql
    AS $func$
        DECLARE
        func_is_graphql_resolve bool;
        BEGIN
        func_is_graphql_resolve = (
            SELECT n.proname = 'resolve'
            FROM pg_event_trigger_ddl_commands() AS ev
            LEFT JOIN pg_catalog.pg_proc AS n
            ON ev.objid = n.oid
        );

        IF func_is_graphql_resolve
        THEN
            grant usage on schema graphql to postgres, anon, authenticated, service_role;
            grant all on function graphql.resolve to postgres, anon, authenticated, service_role;

            alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
            alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
            alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;

            DROP FUNCTION IF EXISTS graphql_public.graphql;
            create or replace function graphql_public.graphql(
                "operationName" text default null,
                query text default null,
                variables jsonb default null,
                extensions jsonb default null
            )
                returns jsonb
                language sql
            as $$
                SELECT graphql.resolve(query, coalesce(variables, '{}'));
            $$;

            grant execute on function graphql.resolve to postgres, anon, authenticated, service_role;
        END IF;

        END;
    $func$;

    DROP EVENT TRIGGER IF EXISTS issue_pg_graphql_access;
    CREATE EVENT TRIGGER issue_pg_graphql_access ON ddl_command_end WHEN TAG in ('CREATE FUNCTION')
    EXECUTE PROCEDURE extensions.grant_pg_graphql_access();
    COMMENT ON FUNCTION extensions.grant_pg_graphql_access IS 'Grants access to pg_graphql';

    -- Trigger upon dropping the pg_graphql extension
    CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()
    RETURNS event_trigger
    LANGUAGE plpgsql
    AS $func$
        DECLARE
        graphql_is_dropped bool;
        BEGIN
        graphql_is_dropped = (
            SELECT ev.schema_name = 'graphql_public'
            FROM pg_event_trigger_dropped_objects() AS ev
            WHERE ev.schema_name = 'graphql_public'
        );

        IF graphql_is_dropped
        THEN
            create or replace function graphql_public.graphql(
                "operationName" text default null,
                query text default null,
                variables jsonb default null,
                extensions jsonb default null
            )
                returns jsonb
                language plpgsql
            as $$
                DECLARE
                    server_version float;
                BEGIN
                    server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);

                    IF server_version >= 14 THEN
                        RETURN jsonb_build_object(
                            'data', null::jsonb,
                            'errors', array['pg_graphql extension is not enabled.']
                        );
                    ELSE
                        RETURN jsonb_build_object(
                            'data', null::jsonb,
                            'errors', array['pg_graphql is only available on projects running Postgres 14 onwards.']
                        );
                    END IF;
                END;
            $$;
        END IF;

        END;
    $func$;

    DROP EVENT TRIGGER IF EXISTS issue_graphql_placeholder;
    CREATE EVENT TRIGGER issue_graphql_placeholder ON sql_drop WHEN TAG in ('DROP EXTENSION')
    EXECUTE PROCEDURE extensions.set_graphql_placeholder();
    COMMENT ON FUNCTION extensions.set_graphql_placeholder IS 'Reintroduces placeholder function for graphql_public.graphql';

    -- migrate:down

  20220321174452_fix-postgrest-alter-type-event-trigger.sql: |
    -- migrate:up

    drop event trigger if exists api_restart;
    drop function if exists extensions.notify_api_restart();

    -- https://postgrest.org/en/latest/schema_cache.html#finer-grained-event-trigger
    -- watch create and alter
    CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch() RETURNS event_trigger AS $$
    DECLARE
      cmd record;
    BEGIN
      FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
      LOOP
        IF cmd.command_tag IN (
          'CREATE SCHEMA', 'ALTER SCHEMA'
        , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'
        , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'
        , 'CREATE VIEW', 'ALTER VIEW'
        , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'
        , 'CREATE FUNCTION', 'ALTER FUNCTION'
        , 'CREATE TRIGGER'
        , 'CREATE TYPE', 'ALTER TYPE'
        , 'CREATE RULE'
        , 'COMMENT'
        )
        -- don't notify in case of CREATE TEMP table or other objects created on pg_temp
        AND cmd.schema_name is distinct from 'pg_temp'
        THEN
          NOTIFY pgrst, 'reload schema';
        END IF;
      END LOOP;
    END; $$ LANGUAGE plpgsql;

    -- watch drop
    CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch() RETURNS event_trigger AS $$
    DECLARE
      obj record;
    BEGIN
      FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
      LOOP
        IF obj.object_type IN (
          'schema'
        , 'table'
        , 'foreign table'
        , 'view'
        , 'materialized view'
        , 'function'
        , 'trigger'
        , 'type'
        , 'rule'
        )
        AND obj.is_temporary IS false -- no pg_temp objects
        THEN
          NOTIFY pgrst, 'reload schema';
        END IF;
      END LOOP;
    END; $$ LANGUAGE plpgsql;

    DROP EVENT TRIGGER IF EXISTS pgrst_ddl_watch;
    CREATE EVENT TRIGGER pgrst_ddl_watch
      ON ddl_command_end
      EXECUTE PROCEDURE extensions.pgrst_ddl_watch();

    DROP EVENT TRIGGER IF EXISTS pgrst_drop_watch;
    CREATE EVENT TRIGGER pgrst_drop_watch
      ON sql_drop
      EXECUTE PROCEDURE extensions.pgrst_drop_watch();


    -- migrate:down

  20220322085208_gotrue-session-limit.sql: |
    -- migrate:up
    ALTER ROLE supabase_auth_admin SET idle_in_transaction_session_timeout TO 60000;

    -- migrate:down

  20220404205710_pg_graphql-on-by-default.sql: |
    -- migrate:up

    -- Update Trigger upon enabling pg_graphql
    create or replace function extensions.grant_pg_graphql_access()
        returns event_trigger
        language plpgsql
    AS $func$
    DECLARE
        func_is_graphql_resolve bool;
    BEGIN
        func_is_graphql_resolve = (
            SELECT n.proname = 'resolve'
            FROM pg_event_trigger_ddl_commands() AS ev
            LEFT JOIN pg_catalog.pg_proc AS n
            ON ev.objid = n.oid
        );

        IF func_is_graphql_resolve
        THEN
            grant usage on schema graphql to postgres, anon, authenticated, service_role;
            grant all on function graphql.resolve to postgres, anon, authenticated, service_role;

            alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
            alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
            alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;

            -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
            DROP FUNCTION IF EXISTS graphql_public.graphql;
            create or replace function graphql_public.graphql(
                "operationName" text default null,
                query text default null,
                variables jsonb default null,
                extensions jsonb default null
            )
                returns jsonb
                language sql
            as $$
                -- This changed
                select graphql.resolve(
                    query := query,
                    variables := coalesce(variables, '{}'),
                    "operationName" := "operationName",
                    extensions := extensions
                );
            $$;

            grant execute on function graphql.resolve to postgres, anon, authenticated, service_role;
        END IF;

    END;
    $func$;

    CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()
    RETURNS event_trigger
    LANGUAGE plpgsql
    AS $func$
        DECLARE
        graphql_is_dropped bool;
        BEGIN
        graphql_is_dropped = (
            SELECT ev.schema_name = 'graphql_public'
            FROM pg_event_trigger_dropped_objects() AS ev
            WHERE ev.schema_name = 'graphql_public'
        );

        IF graphql_is_dropped
        THEN
            create or replace function graphql_public.graphql(
                "operationName" text default null,
                query text default null,
                variables jsonb default null,
                extensions jsonb default null
            )
                returns jsonb
                language plpgsql
            as $$
                DECLARE
                    server_version float;
                BEGIN
                    server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);

                    IF server_version >= 14 THEN
                        RETURN jsonb_build_object(
                            'errors', jsonb_build_array(
                                jsonb_build_object(
                                    'message', 'pg_graphql extension is not enabled.'
                                )
                            )
                        );
                    ELSE
                        RETURN jsonb_build_object(
                            'errors', jsonb_build_array(
                                jsonb_build_object(
                                    'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'
                                )
                            )
                        );
                    END IF;
                END;
            $$;
        END IF;

        END;
    $func$;

    -- GraphQL Placeholder Entrypoint
    create or replace function graphql_public.graphql(
        "operationName" text default null,
        query text default null,
        variables jsonb default null,
        extensions jsonb default null
    )
        returns jsonb
        language plpgsql
    as $$
        DECLARE
            server_version float;
        BEGIN
            server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);

            IF server_version >= 14 THEN
                RETURN jsonb_build_object(
                    'errors', jsonb_build_array(
                        jsonb_build_object(
                            'message', 'pg_graphql extension is not enabled.'
                        )
                    )
                );
            ELSE
                RETURN jsonb_build_object(
                    'errors', jsonb_build_array(
                        jsonb_build_object(
                            'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'
                        )
                    )
                );
            END IF;
        END;
    $$;


    drop extension if exists pg_graphql;
    -- Avoids limitation of only being able to load the extension via dashboard
    -- Only install as well if the extension is actually installed
    DO $$
    DECLARE
      graphql_exists boolean;
    BEGIN
      graphql_exists = (
          select count(*) = 1
          from pg_available_extensions
          where name = 'pg_graphql'
      );

      IF graphql_exists
      THEN
      create extension if not exists pg_graphql;
      END IF;
    END $$;

    -- migrate:down

  20220609081115_grant-supabase-auth-admin-and-supabase-storage-admin-to-postgres.sql: |
    -- migrate:up

    -- This is done so that the `postgres` role can manage auth tables triggers,
    -- storage tables policies, etc. which unblocks the revocation of superuser
    -- access.
    --
    -- More context: https://www.notion.so/supabase/RFC-Postgres-Permissions-I-40cb4f61bd4145fd9e75ce657c0e31dd#bf5d853436384e6e8e339d0a2e684cbb
    grant supabase_auth_admin, supabase_storage_admin to postgres;

    -- migrate:down

  20220613123923_pg_graphql-pg-dump-perms.sql: |
    -- migrate:up

    create or replace function extensions.grant_pg_graphql_access()
        returns event_trigger
        language plpgsql
    AS $func$
    DECLARE
        func_is_graphql_resolve bool;
    BEGIN
        func_is_graphql_resolve = (
            SELECT n.proname = 'resolve'
            FROM pg_event_trigger_ddl_commands() AS ev
            LEFT JOIN pg_catalog.pg_proc AS n
            ON ev.objid = n.oid
        );

        IF func_is_graphql_resolve
        THEN
            -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
            DROP FUNCTION IF EXISTS graphql_public.graphql;
            create or replace function graphql_public.graphql(
                "operationName" text default null,
                query text default null,
                variables jsonb default null,
                extensions jsonb default null
            )
                returns jsonb
                language sql
            as $$
                select graphql.resolve(
                    query := query,
                    variables := coalesce(variables, '{}'),
                    "operationName" := "operationName",
                    extensions := extensions
                );
            $$;

            -- This hook executes when `graphql.resolve` is created. That is not necessarily the last
            -- function in the extension so we need to grant permissions on existing entities AND
            -- update default permissions to any others that are created after `graphql.resolve`
            grant usage on schema graphql to postgres, anon, authenticated, service_role;
            grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;
            grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;
            grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
            alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
            alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
            alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;
        END IF;

    END;
    $func$;

    -- Cycle the extension off and back on to apply the permissions update.

    drop extension if exists pg_graphql;
    -- Avoids limitation of only being able to load the extension via dashboard
    -- Only install as well if the extension is actually installed
    DO $$
    DECLARE
      graphql_exists boolean;
    BEGIN
      graphql_exists = (
          select count(*) = 1 
          from pg_available_extensions 
          where name = 'pg_graphql'
      );

      IF graphql_exists 
      THEN
      create extension if not exists pg_graphql;
      END IF;
    END $$;

    -- migrate:down

  20220713082019_pg_cron-pg_net-temp-perms-fix.sql: |
    -- migrate:up
    DO $$
    DECLARE
      pg_cron_installed boolean;
    BEGIN
      -- checks if pg_cron is enabled   
      pg_cron_installed = (
        select count(*) = 1 
        from pg_available_extensions 
        where name = 'pg_cron'
        and installed_version is not null
      );

      IF pg_cron_installed
      THEN
        grant usage on schema cron to postgres with grant option;
        grant all on all functions in schema cron to postgres with grant option;

        alter default privileges in schema cron grant all on tables to postgres with grant option;
        alter default privileges in schema cron grant all on functions to postgres with grant option;
        alter default privileges in schema cron grant all on sequences to postgres with grant option;

        alter default privileges for user supabase_admin in schema cron grant all
            on sequences to postgres with grant option;
        alter default privileges for user supabase_admin in schema cron grant all
            on tables to postgres with grant option;
        alter default privileges for user supabase_admin in schema cron grant all
            on functions to postgres with grant option;

        grant all privileges on all tables in schema cron to postgres with grant option; 
      END IF;
    END $$;

    DO $$
    DECLARE
      pg_net_installed boolean;
    BEGIN
      -- checks if pg_net is enabled
      pg_net_installed = (
        select count(*) = 1 
        from pg_available_extensions 
        where name = 'pg_net'
        and installed_version is not null

      );

      IF pg_net_installed 
      THEN
        IF NOT EXISTS (
          SELECT 1
          FROM pg_roles
          WHERE rolname = 'supabase_functions_admin'
        )
        THEN
          CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
        END IF;

        GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;

        ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
        ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;

        ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
        ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;

        REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
        REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;

        GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
        GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
      END IF;
    END $$;

    -- migrate:down

  20221028101028_set_authenticator_timeout.sql: |
    -- migrate:up
    alter role authenticator set statement_timeout = '8s';

    -- migrate:down


  20221103090837_revoke_admin.sql: |
    -- migrate:up
    revoke supabase_admin from authenticator;

    -- migrate:down


  20221207154255_create_pgsodium_and_vault.sql: |
    -- migrate:up

    DO $$
    DECLARE
      pgsodium_exists boolean;
      vault_exists boolean;
    BEGIN
      IF EXISTS (SELECT FROM pg_available_extensions WHERE name = 'supabase_vault' AND default_version != '0.2.8') THEN
        CREATE EXTENSION IF NOT EXISTS supabase_vault;

        -- for some reason extension custom scripts aren't run during AMI build, so
        -- we manually run it here
        GRANT USAGE ON SCHEMA vault TO postgres WITH GRANT OPTION;
        GRANT SELECT, DELETE ON vault.secrets, vault.decrypted_secrets TO postgres WITH GRANT OPTION;
        GRANT EXECUTE ON FUNCTION vault.create_secret, vault.update_secret, vault._crypto_aead_det_decrypt TO postgres WITH GRANT OPTION;
      ELSE
        pgsodium_exists = (
          select count(*) = 1 
          from pg_available_extensions 
          where name = 'pgsodium'
          and default_version in ('3.1.6', '3.1.7', '3.1.8', '3.1.9')
        );

        vault_exists = (
            select count(*) = 1 
            from pg_available_extensions 
            where name = 'supabase_vault'
        );

        IF pgsodium_exists 
        THEN
          create extension if not exists pgsodium;

          grant pgsodium_keyiduser to postgres with admin option;
          grant pgsodium_keyholder to postgres with admin option;
          grant pgsodium_keymaker  to postgres with admin option;

          grant execute on function pgsodium.crypto_aead_det_decrypt(bytea, bytea, uuid, bytea) to service_role;
          grant execute on function pgsodium.crypto_aead_det_encrypt(bytea, bytea, uuid, bytea) to service_role;
          grant execute on function pgsodium.crypto_aead_det_keygen to service_role;

          IF vault_exists
          THEN
            create extension if not exists supabase_vault;
          END IF;
        END IF;
      END IF;
    END $$;

    -- migrate:down

  20230201083204_grant_auth_roles_to_postgres.sql: |
    -- migrate:up
    grant anon, authenticated, service_role to postgres;

    -- migrate:down


  20230224042246_grant_extensions_perms_for_postgres.sql: |
    -- migrate:up
    grant all privileges on all tables in schema extensions to postgres with grant option;
    grant all privileges on all routines in schema extensions to postgres with grant option;
    grant all privileges on all sequences in schema extensions to postgres with grant option;
    alter default privileges in schema extensions grant all on tables to postgres with grant option;
    alter default privileges in schema extensions grant all on routines to postgres with grant option;
    alter default privileges in schema extensions grant all on sequences to postgres with grant option;

    -- migrate:down


  20230306081037_grant_pg_monitor_to_postgres.sql: |
    -- migrate:up
    grant pg_monitor to postgres;

    -- migrate:down


  20230327032006_grant_auth_roles_to_supabase_storage_admin.sql: |
    -- migrate:up
    grant anon, authenticated, service_role to supabase_storage_admin;

    -- migrate:down

  20230529180330_alter_api_roles_for_inherit.sql: |
    -- migrate:up

    ALTER ROLE authenticated inherit;
    ALTER ROLE anon inherit;
    ALTER ROLE service_role inherit;

    DO $$
    BEGIN
      IF EXISTS (SELECT FROM pg_roles WHERE rolname = 'pgsodium_keyholder') THEN
        GRANT pgsodium_keyholder to service_role;
      END IF;
    END $$;

    -- migrate:down


  20231013070755_grant_authenticator_to_supabase_storage_admin.sql: |
    -- migrate:up
    grant authenticator to supabase_storage_admin;
    revoke anon, authenticated, service_role from supabase_storage_admin;

    -- migrate:down

  20231017062225_grant_pg_graphql_permissions_for_custom_roles.sql: |
    -- migrate:up

    create or replace function extensions.grant_pg_graphql_access()
        returns event_trigger
        language plpgsql
    AS $func$
    DECLARE
        func_is_graphql_resolve bool;
    BEGIN
        func_is_graphql_resolve = (
            SELECT n.proname = 'resolve'
            FROM pg_event_trigger_ddl_commands() AS ev
            LEFT JOIN pg_catalog.pg_proc AS n
            ON ev.objid = n.oid
        );

        IF func_is_graphql_resolve
        THEN
            -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
            DROP FUNCTION IF EXISTS graphql_public.graphql;
            create or replace function graphql_public.graphql(
                "operationName" text default null,
                query text default null,
                variables jsonb default null,
                extensions jsonb default null
            )
                returns jsonb
                language sql
            as $$
                select graphql.resolve(
                    query := query,
                    variables := coalesce(variables, '{}'),
                    "operationName" := "operationName",
                    extensions := extensions
                );
            $$;

            -- This hook executes when `graphql.resolve` is created. That is not necessarily the last
            -- function in the extension so we need to grant permissions on existing entities AND
            -- update default permissions to any others that are created after `graphql.resolve`
            grant usage on schema graphql to postgres, anon, authenticated, service_role;
            grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;
            grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;
            grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
            alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
            alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
            alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;

            -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles
            grant usage on schema graphql_public to postgres with grant option;
            grant usage on schema graphql to postgres with grant option;
        END IF;

    END;
    $func$;

    -- Cycle the extension off and back on to apply the permissions update.

    drop extension if exists pg_graphql;
    -- Avoids limitation of only being able to load the extension via dashboard
    -- Only install as well if the extension is actually installed
    DO $$
    DECLARE
      graphql_exists boolean;
    BEGIN
      graphql_exists = (
          select count(*) = 1 
          from pg_available_extensions 
          where name = 'pg_graphql'
      );

      IF graphql_exists 
      THEN
      create extension if not exists pg_graphql;
      END IF;
    END $$;

    -- migrate:down

  20231020085357_revoke_writes_on_cron_job_from_postgres.sql: |
    -- migrate:up
    do $$
    begin
      if exists (select from pg_extension where extname = 'pg_cron') then
        revoke all on table cron.job from postgres;
        grant select on table cron.job to postgres with grant option;
      end if;
    end $$;

    CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access() RETURNS event_trigger
        LANGUAGE plpgsql
        AS $$
    BEGIN
      IF EXISTS (
        SELECT
        FROM pg_event_trigger_ddl_commands() AS ev
        JOIN pg_extension AS ext
        ON ev.objid = ext.oid
        WHERE ext.extname = 'pg_cron'
      )
      THEN
        grant usage on schema cron to postgres with grant option;

        alter default privileges in schema cron grant all on tables to postgres with grant option;
        alter default privileges in schema cron grant all on functions to postgres with grant option;
        alter default privileges in schema cron grant all on sequences to postgres with grant option;

        alter default privileges for user supabase_admin in schema cron grant all
            on sequences to postgres with grant option;
        alter default privileges for user supabase_admin in schema cron grant all
            on tables to postgres with grant option;
        alter default privileges for user supabase_admin in schema cron grant all
            on functions to postgres with grant option;

        grant all privileges on all tables in schema cron to postgres with grant option;
        revoke all on table cron.job from postgres;
        grant select on table cron.job to postgres with grant option;
      END IF;
    END;
    $$;

    drop event trigger if exists issue_pg_cron_access;
    CREATE EVENT TRIGGER issue_pg_cron_access ON ddl_command_end
             WHEN TAG IN ('CREATE EXTENSION')
       EXECUTE FUNCTION extensions.grant_pg_cron_access();

    -- migrate:down

  20231130133139_set_lock_timeout_to_authenticator_role.sql: |
    -- migrate:up
    ALTER ROLE authenticator set lock_timeout to '8s';

    -- migrate:down

  20240124080435_alter_lo_export_lo_import_owner.sql: |
    -- migrate:up
    -- alter function pg_catalog.lo_export owner to supabase_admin;
    -- alter function pg_catalog.lo_import(text) owner to supabase_admin;
    -- alter function pg_catalog.lo_import(text, oid) owner to supabase_admin;

    -- migrate:down

  20240606060239_grant_predefined_roles_to_postgres.sql: |
    -- migrate:up
    grant pg_read_all_data, pg_signal_backend to postgres;

    -- migrate:down

  20241031003909_create_orioledb.sql: |
    -- migrate:up
    do $$ 
    begin 
        if exists (select 1 from pg_available_extensions where name = 'orioledb') then
            if not exists (select 1 from pg_extension where extname = 'orioledb') then
                create extension if not exists orioledb;
            end if;
        end if;
    end $$;

    -- migrate:down

  20241215003910_backfill_pgmq_metadata.sql: |
    -- migrate:up
    do $$
    begin
        -- Check if the pgmq.meta table exists
        if exists (
            select
                1
            from
                pg_catalog.pg_class c
            join pg_catalog.pg_namespace n
                on c.relnamespace = n.oid
            where
                n.nspname = 'pgmq'
                and c.relname = 'meta'
                and c.relkind = 'r' -- regular table
                -- Make sure only expected columns exist and are correctly named
                and (
                    select array_agg(attname::text order by attname)
                    from pg_catalog.pg_attribute a
                    where
                    a.attnum > 0
                    and a.attrelid = c.oid 
                ) = array['created_at', 'is_partitioned', 'is_unlogged', 'queue_name']::text[]
        ) then
            -- Insert data into pgmq.meta for all tables matching the naming pattern 'pgmq.q_<queue_name>'
            insert into pgmq.meta (queue_name, is_partitioned, is_unlogged, created_at)
            select
                substring(c.relname from 3) as queue_name,
                false as is_partitioned,
                case when c.relpersistence = 'u' then true else false end as is_unlogged,
                now() as created_at
            from
    			pg_catalog.pg_class c
            	join pg_catalog.pg_namespace n
    				on c.relnamespace = n.oid
            where
                n.nspname = 'pgmq'
                and c.relname like 'q_%'
                and c.relkind in ('r', 'p', 'u')
            on conflict (queue_name) do nothing;
        end if;
    end $$;

    -- For logical backups we detach the queue and archive tables from the pgmq extension
    -- prior to pausing. Once detached, pgmq.drop_queue breaks. This re-attaches them 
    -- when a project is unpaused and allows pgmq.drop_queue to work normally.
    do $$
    declare
        ext_exists boolean;
        tbl record;
    begin
        -- check if pgmq extension is installed
        select exists(select 1 from pg_extension where extname = 'pgmq') into ext_exists;

        if ext_exists then
            for tbl in
                select c.relname as table_name
                from pg_class c
                join pg_namespace n on c.relnamespace = n.oid
                where n.nspname = 'pgmq'
                  and c.relkind in ('r', 'u')  -- include ordinary and unlogged tables
                  and (c.relname like 'q\_%' or c.relname like 'a\_%')
                  and c.oid not in (
                      select d.objid
                      from pg_depend d
                      join pg_extension e on d.refobjid = e.oid
                      where e.extname = 'pgmq'
                        and d.classid = 'pg_class'::regclass
                        and d.deptype = 'e'
                  )
            loop
                execute format('alter extension pgmq add table pgmq.%I', tbl.table_name);
            end loop;
        end if;
    end;
    $$;


    -- migrate:down

  20250205060043_disable_log_statement_on_internal_roles.sql: |
    -- migrate:up
    alter role supabase_admin set log_statement = none;
    alter role supabase_auth_admin set log_statement = none;
    alter role supabase_storage_admin set log_statement = none;

    -- migrate:down

  20250205144616_move_orioledb_to_extensions_schema.sql: |
    -- migrate:up
    do $$
    declare
        ext_schema text;
        extensions_schema_exists boolean;
    begin
        -- check if the "extensions" schema exists
        select exists (
            select 1 from pg_namespace where nspname = 'extensions'
        ) into extensions_schema_exists;

        if extensions_schema_exists then
            -- check if the "orioledb" extension is in the "public" schema
            select nspname into ext_schema
            from pg_extension e
            join pg_namespace n on e.extnamespace = n.oid
            where extname = 'orioledb';

            if ext_schema = 'public' then
                execute 'alter extension orioledb set schema extensions';
            end if;
        end if;
    end $$;

    -- migrate:down


  20250218031949_pgsodium_mask_role.sql: |
    -- migrate:up

    DO $$
    BEGIN
      IF EXISTS (SELECT FROM pg_extension WHERE extname = 'pgsodium') THEN
        CREATE OR REPLACE FUNCTION pgsodium.mask_role(masked_role regrole, source_name text, view_name text)
        RETURNS void
        LANGUAGE plpgsql
        SECURITY DEFINER
        SET search_path TO ''
        AS $function$
        BEGIN
          EXECUTE format(
            'GRANT SELECT ON pgsodium.key TO %s',
            masked_role);

          EXECUTE format(
            'GRANT pgsodium_keyiduser, pgsodium_keyholder TO %s',
            masked_role);

          EXECUTE format(
            'GRANT ALL ON %I TO %s',
            view_name,
            masked_role);
          RETURN;
        END
        $function$;
      END IF;
    END $$;

    -- migrate:down

  20250220051611_pg_net_perms_fix.sql: |
    -- migrate:up
    CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()
    RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
    BEGIN
      IF EXISTS (
        SELECT 1
        FROM pg_event_trigger_ddl_commands() AS ev
        JOIN pg_extension AS ext
        ON ev.objid = ext.oid
        WHERE ext.extname = 'pg_net'
      )
      THEN
        IF NOT EXISTS (
          SELECT 1
          FROM pg_roles
          WHERE rolname = 'supabase_functions_admin'
        )
        THEN
          CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
        END IF;

        GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;

        IF EXISTS (
          SELECT FROM pg_extension
          WHERE extname = 'pg_net'
          -- all versions in use on existing projects as of 2025-02-20
          -- version 0.12.0 onwards don't need these applied
          AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')
        ) THEN
          ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
          ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;

          ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
          ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;

          REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
          REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;

          GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
          GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
        END IF;
      END IF;
    END;
    $$;

    DO $$
    BEGIN
      IF EXISTS (SELECT FROM pg_extension WHERE extname = 'pg_net')
      THEN
        ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY INVOKER;
        ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY INVOKER;

        REVOKE EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM supabase_functions_admin, postgres, anon, authenticated, service_role;
        REVOKE EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM supabase_functions_admin, postgres, anon, authenticated, service_role;

        GRANT ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO PUBLIC;
        GRANT ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO PUBLIC;
      END IF;
    END $$;

    -- migrate:down

  20250312095419_pgbouncer_ownership.sql: |
    -- migrate:up
    alter function pgbouncer.get_auth owner to supabase_admin;
    grant execute on function pgbouncer.get_auth(p_usename text) to postgres;

    -- migrate:down

  97-_supabase.sql: |
    \set pguser `echo "$POSTGRES_USER"`

    CREATE DATABASE _supabase WITH OWNER :pguser;

  99-logs.sql: |
    \set pguser `echo "$POSTGRES_USER"`

    \c _supabase
    create schema if not exists _analytics;
    alter schema _analytics owner to :pguser;
    \c postgres

  99-pooler.sql: |
    \set pguser `echo "$POSTGRES_USER"`

    \c _supabase
    create schema if not exists _supavisor;
    alter schema _supavisor owner to :pguser;
    \c postgres

  99-realtime.sql: |
    \set pguser `echo "$POSTGRES_USER"`

    create schema if not exists _realtime;
    alter schema _realtime owner to :pguser;
  {{- range $name, $content := .Values.db.config }}
  {{ $name }}: |
    {{ $content | nindent 4 }}
  {{- end }}
{{- end }}
